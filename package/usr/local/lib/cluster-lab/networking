#!/usr/bin/env bash

################
##### VLAN #####
################
configure_vlan(){
    #echo "create vlan with tag VLAN_ID on eth0"
    ip link add link eth0 name "${VLAN_INTERFACE}" type vlan id "${VLAN_ID}"
    ip link set dev "${VLAN_INTERFACE}" up
}

reset_vlan(){
    #echo "deleting existing vlan interface"
    ip link delete dev "${VLAN_INTERFACE}" type vlan
}

####################
#### IP config #####
####################
ip_set () {
    local IP="$1"
    #echo "set ip address on vlan 200"
    ip addr add "${IP}""${NETMASK}" dev "${VLAN_INTERFACE}"
    ip link set dev "${VLAN_INTERFACE}" up
}

ip_request () {
    #echo "get ip address from DHCP"
    ip link set dev "${VLAN_INTERFACE}" up
    # use the systemd way for dhclient
cat << EOM > /etc/systemd/network/"${VLAN_INTERFACE}".network
[Match]
Name=${VLAN_INTERFACE}

[Network]
DHCP=yes
EOM
    systemctl restart systemd-networkd.service
    sleep 2
    echo "IP on ${VLAN_INTERFACE} is: $(find_ip_of_if "${VLAN_INTERFACE}")"
}
#########################
##### IP networking #####
#########################
check_ip () {
    local IP=$1
    local HOSTNAME_IPS=$(hostname -I)
    local i=""
    for i in $HOSTNAME_IPS; do
        if [[ "$i" == *"$IP"* ]]; then
            echo "$ip"
        fi
    done
}
check_ip_bool () {
    local IP="$1"
    local check=$(check_ip "$IP")
    if [[ -n "$check" ]]; then
        return 0
    else
        return 1
    fi

}
find_ip_of_if () {
    local INTERFACE=$1
    local HOSTNAME_IPS=$(hostname -I)
    local IPA_IP=$(ip a s "$INTERFACE")
    local i=""
    for i in $HOSTNAME_IPS; do
        if [[ "$IPA_IP" == *"$i"* ]]; then
          echo "$i"
        fi
    done
}
check_linklocal () {
    local IP="169.254."
    check_ip_bool "$IP"
}

find_if_for_ip () {
    local IP_TO_FIND=$1
    local INTERFACES=$(ip link | grep -v "link/" | awk -F": " '{print $2}')
    local i
    for i in $INTERFACES; do
        local check=$(find_ip_of_if "$i")
        if [[ "$check" == "$IP_TO_FIND" ]]; then
            echo "$i"
        fi
    done
}

fix_routing () {
    # update routes
    local IP=8.8.8.8
    # test if default route for VLAN_INTERFACE
    ip route | grep default | grep "${VLAN_INTERFACE}"  > /dev/null 2>&1;
    if [[ $? == 0 ]]; then
        # remove route if exists
        ip route del default dev "${VLAN_INTERFACE}"
    fi
    # check ping google ip
    ping -c 1 "$IP" > /dev/null 2>&1;
    if [[ $? == 0 ]]; then
        # return on success
        return 0
    fi

    local counter=0
    # try 10 times with 1 sec pause between each
    while [ $counter -lt 10 ]; do
        local status="$(ip link show dev eth0 | grep \"state UP\")"
        if [[ -z "$status" ]]; then
            ip link set dev eth0 up
        else
            counter=$(( counter + 10 ))
        fi
        conter=$(( conter + 1 ))
        sleep 1
    done
    echo "link eth0 down"
    return 1

    # test if default route for eth0
    ip route | grep default | grep eth0  > /dev/null 2>&1;
    if [[ $? == 0 ]]; then
        # return on success
        return 0
    fi

    counter=0
    # try 10 times with 1 sec pause between each
    while [ $counter -lt 10 ]; do
        echo "Request new IP"
        dhclient eth0
        if [[ $? == 0 ]]; then
            # return on success
            return 0
        fi
        counter=$(( counter + 1 ))
        sleep 2
    done
    echo "Routing broken"
    return 1
}

fix_dns(){
  sed -i '1i nameserver 8.8.8.8\n' /etc/resolv.conf
}

function configure_networking(){
  configure_vlan
}

function reset_networking(){
  reset_vlan
}


function pre_check_networking(){
  echo -e "\nNetworking"
  ERRORS=0

  ip link show | grep -q eth0
  evaluate_result $? "  eth0 exists"

  ping -W 1 -c 2 8.8.8.8 > /dev/null 2>&1
  evaluate_result $? "  Internet is reachable"

  timeout 1 ping -c 1 google.com > /dev/null 2>&1
  evaluate_result $? "  DNS works"

  return $ERRORS
}

function post_check_networking(){
  echo -e "\nNetworking"
  ERRORS=0

  ip link show | grep -q eth0
  evaluate_result $? "  eth0 exists"

  ping -W 1 -c 2 8.8.8.8 > /dev/null 2>&1
  evaluate_result $? "  Internet is reachable"

  timeout 1 ping -c 1 google.com > /dev/null 2>&1
  evaluate_result $? "  DNS works"

  ip link show | grep -q eth0.${VLAN_ID}
  evaluate_result $? "  eth0.${VLAN_ID} exists"

  # check if the vlan 192.168.200 subnet exists
  regex="$(escape_ip_for_regex "${VLAN_SUBNET}")\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
  [[ "$(ip_of_interface eth0.${VLAN_ID})" =~ $regex ]]
  evaluate_result $? "  eth0.${VLAN_ID} has correct IP from vlan network"

  ping -W 1 -c 2 "${VLAN_LEADER_IP}" > /dev/null 2>&1
  evaluate_result $? "  Cluster leader is reachable"

  number_of_ips=$(ip addr show dev eth0.${VLAN_ID} | grep -c "inet\s")
  [[ "$number_of_ips" -eq 1 ]]
  evaluate_result $? "  eth0.${VLAN_ID} has exactly one IP"

  regex="169\.254\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$"
  [[ ! "$(ip_of_interface eth0.${VLAN_ID})" =~ $regex ]]
  evaluate_result $? "  eth0.${VLAN_ID} has no local link address"

  return $ERRORS
}
